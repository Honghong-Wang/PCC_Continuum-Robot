import numpy as np

# Spatial Robot Kinematics Functions

# Homogeneous transformation matrix
def trans_mat_cc(kappa, l, phi):
    """
    Mapping from configuration parameters to task space
    tip frame is aligned so that the x-axis points toward the center of the circle

    Parameters
    ----------
    kappa : float
        curvature
    l : float
        trunk length

    Returns
    -------
    T: Transformation matrices containing orientation and position

    """

    # num = sect_points: points per section
    si=np.linspace(0,l, num = 50);
    T= np.zeros((len(si),16));

    c_p=np.cos(phi);
    s_p=np.sin(phi);
    
    for i in range(len(si)):
        s=si[i];
        c_ks=np.cos(kappa*s);
        s_ks=np.sin(kappa*s);
        if kappa==0:
            T[i,:] = np.array([c_p*c_ks,s_p*s_ks,s_ks,0, -s_p,c_p,0,0, -c_p*s_ks,-s_p*s_ks,c_ks,0, 0,0,s,1]);  
        else:
            T[i,:] = np.array([c_p*c_ks,s_p*s_ks,s_ks,0, -s_p,c_p,0,0, -c_p*s_ks,-s_p*s_ks,c_ks,0, (1/kappa)*(-c_p+c_p*c_ks),(1/kappa)*(-s_p+s_p*c_ks),s_ks/kappa,1]);

    return T


# The forward kinematics for an n section manipulator can then be generated by the product of 
# n matrices. The forward kinematics for our elephant trunk robot 
# with its n sections can be calculated as
def coupletransformations(T,T_tip):
    """
    Find orientation and position of distal section
    (Multiply T of current section with T at tip of previous section)

    Parameters
    ----------
    T : Array of float64
        Transformation matrices of current section.
    T_tip : Array of float64
        Transformation at tip of previous section.

    Returns
    -------
    Tc: coupled Transformation matrix.

    """
    
    Tc=np.zeros((len(T[:,0]),len(T[0,:])));
    for k in range(len(T[:,0])):
        #Tc[k,:].reshape(-1,1)
        p = np.matmul(T_tip,(np.reshape(T[k,:],(4,4),order='F')))
        Tc[k,:] = np.reshape(p,(16,),order='F');
    return Tc